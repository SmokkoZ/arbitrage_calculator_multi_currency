<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Surebet Ops Console</title>
  <link rel="stylesheet" href="style.css" />

  <!-- Optional favicon hook -->
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="favicon.png" />
  <link rel="apple-touch-icon" href="favicon.png" />
  <meta name="theme-color" content="#0a0f1f" />
</head>

<body>
  <div class="app-shell">
    <!-- HEADER -->
    <header class="header-card glass-card">
      <div class="header-main">
        <h1>Arbitrage Calculator</h1>
        <p class="tagline">2-way sizing, FX-locked, tax-aware 🇷🇴</p>
      </div>

      <div class="fx-fetch-block">
        <button id="fetchRatesBtn" class="btn-primary">Fetch Rates (EUR base)</button>
        <div class="fetch-hint">Snapshot once per 24h for accounting.</div>
        <div id="fetchStatus" class="status-msg"></div>
      </div>
    </header>

    <main class="main-col">
      <!-- =============== FX SNAPSHOT =============== -->
      <section class="glass-card panel panel-compact">
        <div class="panel-head-row">
          <h2 class="panel-title small-gap">FX Snapshot (EUR →)</h2>
          <div id="fxTimestamp" class="fx-timestamp tiny-ts">No rates loaded</div>
        </div>

        <div id="fxTable" class="fx-table fx-table-inline"></div>

        <details class="manual-wrapper">
          <summary class="manual-summary">
            Manual rates override
            <span class="manual-hint">(use if API blocked)</span>
          </summary>

          <div class="inline-manual">
            <div class="manual-row">
              <label for="manualGBP">1€ =</label>
              <input type="number" step="0.0001" id="manualGBP" placeholder="GBP" />
              <span class="manual-cur">GBP</span>
            </div>

            <div class="manual-row">
              <label for="manualRON">1€ =</label>
              <input type="number" step="0.0001" id="manualRON" placeholder="RON" />
              <span class="manual-cur">RON</span>
            </div>

            <div class="manual-row">
              <label for="manualAUD">1€ =</label>
              <input type="number" step="0.0001" id="manualAUD" placeholder="AUD" />
              <span class="manual-cur">AUD</span>
            </div>

            <button class="btn-primary wide" id="saveManualBtn">Save Manual Rates</button>
            <div class="field-hint" style="margin-top:0.5rem;">Saves locally and locks calculator to this snapshot.</div>
          </div>
        </details>
      </section>

      <!-- =============== CALCULATOR =============== -->
      <section class="glass-card panel">
        <h2 class="panel-title">Surebet Sizing</h2>

        <!-- MODE TOGGLE -->
        <div class="note-box mode-box">
          <div class="mode-option">
            <label class="mode-label">
              <input type="radio" name="calcMode" value="stakeA" id="modeStakeA" checked />
              <div>
                <div class="mode-title">I know Stake A</div>
                <div class="mode-desc">I enter Stake A cash. You solve Stake B cash.</div>
              </div>
            </label>
          </div>

          <div class="mode-option">
            <label class="mode-label">
              <input type="radio" name="calcMode" value="stakeB" id="modeStakeB" />
              <div>
                <div class="mode-title">I know Stake B</div>
                <div class="mode-desc">I enter Stake B cash. You solve Stake A cash.</div>
              </div>
            </label>
          </div>

          <div class="mode-option">
            <label class="mode-label">
              <input type="radio" name="calcMode" value="targetEUR" id="modeTargetEUR" />
              <div>
                <div class="mode-title">Target guaranteed payout in EUR</div>
                <div class="mode-desc">I enter the EUR I want guaranteed. You solve both stakes.</div>
              </div>
            </label>
          </div>
        </div>

        <!-- BALANCING METHOD -->
        <div class="balance-row">
          <div class="balance-left">
            <label class="balance-label">Balance by:</label>
            <label class="balance-pill">
              <input type="radio" name="balMethod" value="after" id="balAfter" checked />
              After-tax net payout (EUR)
            </label>
            <label class="balance-pill">
              <input type="radio" name="balMethod" value="pre" id="balPre" />
              Pre-tax slip payout (EUR)
            </label>
          </div>
          <div class="balance-right">
            <span id="balBadge" class="bal-badge">After-tax net payout (EUR)</span>
          </div>
        </div>
        <div id="balHint" class="tiny-hint soft-warn hidden">
          RON detected on one side — balancing **after tax** is recommended for symmetric ROI.
        </div>

        <!-- FORM -->
        <form id="calcForm" class="calc-form">
          <!-- SIDE A -->
          <div class="h-row">
            <div class="field slim">
              <label for="oddsA">Odds A</label>
              <input type="number" step="0.0001" id="oddsA" placeholder="e.g. 1.53" required />
            </div>

            <div class="field slim">
              <label for="currencyA">Curr A</label>
              <select id="currencyA">
                <option value="EUR">EUR</option>
                <option value="GBP">GBP</option>
                <option value="RON">RON 🇷🇴</option>
                <option value="AUD">AUD</option>
              </select>
              <div class="tiny-hint-line" id="hintA"></div>
            </div>

            <div class="field slim">
              <label for="stakeA">Stake A cash in</label>
              <input type="number" step="0.01" id="stakeA" placeholder="e.g. 100" />
              <div class="tiny-hint-line">Used in "I know Stake A".</div>
            </div>
          </div>

          <!-- SIDE B -->
          <div class="h-row">
            <div class="field slim">
              <label for="oddsB">Odds B</label>
              <input type="number" step="0.0001" id="oddsB" placeholder="e.g. 2.80" required />
            </div>

            <div class="field slim">
              <label for="currencyB">Curr B</label>
              <select id="currencyB">
                <option value="EUR">EUR</option>
                <option value="GBP">GBP</option>
                <option value="RON">RON 🇷🇴</option>
                <option value="AUD">AUD</option>
              </select>
              <div class="tiny-hint-line" id="hintB"></div>
            </div>

            <div class="field slim">
              <label for="stakeB">Stake B cash in</label>
              <input type="number" step="0.01" id="stakeB" placeholder="e.g. 80" />
              <div class="tiny-hint-line">Used in "I know Stake B".</div>
            </div>
          </div>

          <!-- TARGET PAYOUT -->
          <div class="h-row">
            <div class="field slim">
              <label for="targetPayout">Guaranteed payout target (EUR)</label>
              <input type="number" step="0.01" id="targetPayout" placeholder="e.g. 200" />
              <div class="tiny-hint-line">Used in "Target guaranteed payout in EUR".</div>
            </div>
          </div>

          <div class="calc-btn-row">
            <button class="btn-primary" id="calcBtn">Calculate</button>
          </div>
        </form>

        <div id="calcError" class="error-msg hidden"></div>

        <!-- =============== RESULTS =============== -->
        <div id="calcResult" class="result-card hidden">
          <!-- 1. STAKES -->
          <h3>Your stakes (what to place)</h3>
          <div class="stakes-block">
            <div class="stake-side">
              <div class="stake-side-header">
                <span class="side-label">Side A</span>
                <span class="side-odds" id="sideAOddsOut">@ ?</span>
              </div>
              <div class="stake-row">
                <span class="stake-label">Cash in:</span>
                <span class="stake-val" id="stakeACashOut">-</span>
              </div>
              <div class="stake-row">
                <span class="stake-label">Slip stake after fee:</span>
                <span class="stake-val" id="stakeAEffOut">-</span>
              </div>
            </div>

            <div class="stake-side">
              <div class="stake-side-header">
                <span class="side-label">Side B</span>
                <span class="side-odds" id="sideBOddsOut">@ ?</span>
              </div>
              <div class="stake-row">
                <span class="stake-label">Cash in:</span>
                <span class="stake-val" id="stakeBCashOut">-</span>
              </div>
              <div class="stake-row">
                <span class="stake-label">Slip stake after fee:</span>
                <span class="stake-val" id="stakeBEffOut">-</span>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <!-- 2. OUTCOMES -->
          <h4 class="subhead">If each side wins (after country taxes)</h4>
          <div class="outcomes-grid">
            <div class="outcome-card">
              <div class="outcome-head">
                <span class="outcome-title">If Side A wins</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Cash you collect from A:</span>
                <span class="out-val" id="collectAOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Total cost you paid in:</span>
                <span class="out-val" id="totalCostAOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Profit after tax (EUR):</span>
                <span class="out-val greenish" id="profitAEurOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">ROI after tax:</span>
                <span class="out-val" id="roiAOut">-</span>
              </div>
            </div>

            <div class="outcome-card">
              <div class="outcome-head">
                <span class="outcome-title">If Side B wins</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Cash you collect from B:</span>
                <span class="out-val" id="collectBOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Total cost you paid in:</span>
                <span class="out-val" id="totalCostBOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">Profit after tax (EUR):</span>
                <span class="out-val greenish" id="profitBEurOut">-</span>
              </div>
              <div class="outcome-row">
                <span class="out-label">ROI after tax:</span>
                <span class="out-val" id="roiBOut">-</span>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <!-- 3. GUARANTEED -->
          <div class="guarantee-block">
            <div class="guarantee-row">
              <span class="guarantee-label">Guaranteed profit floor (EUR):</span>
              <span class="guarantee-val greenish" id="guaranteedProfitOut">-</span>
            </div>
            <div class="guarantee-row">
              <span class="guarantee-label">Guaranteed ROI floor:</span>
              <span class="guarantee-val" id="guaranteedRoiOut">-</span>
            </div>
            <div class="guarantee-row">
              <span class="guarantee-label">Arbitrage check:</span>
              <span class="guarantee-val" id="arbOut">-</span>
            </div>
          </div>

          <div class="tiny-hint" id="fxUsedLine"></div>
        </div>
      </section>
    </main>

    <footer class="footer-card glass-card">
      <div class="foot-left"><strong>Local operator use only.</strong> One human. One machine.</div>
      <div class="foot-right">Snap FX → Size bets → Log EUR profit → Settle later.</div>
    </footer>
  </div>

  <script>
    /***********************
     * GLOBAL
     ***********************/
    let fxRates = null;       // { EUR:1, GBP:x, RON:y, AUD:z }
    let fxTimestamp = null;
    const RATES_STORAGE_KEY = "surebet_fx_snapshot_v3";

    const $ = sel => document.querySelector(sel);
    const setText = (sel, txt) => { const el = $(sel); if (el) el.textContent = txt; };
    const show = el => el.classList.remove("hidden");
    const hide = el => el.classList.add("hidden");

    /***********************
     * STORAGE & LOCK
     ***********************/
    function loadRatesFromStorage() {
      try {
        const raw = localStorage.getItem(RATES_STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.rates || !parsed.timestamp) return;
        fxRates = parsed.rates;
        fxTimestamp = parsed.timestamp;
        renderFxSnapshot();
        lockFetchBtnIfNeeded();
      } catch (_) { }
    }
    function saveRatesToStorage() {
      if (!fxRates || !fxTimestamp) return;
      localStorage.setItem(RATES_STORAGE_KEY, JSON.stringify({ rates: fxRates, timestamp: fxTimestamp }));
    }
    function isWithin24h(ts) {
      return (Date.now() - ts) < 24 * 60 * 60 * 1000;
    }
    function lockFetchBtnIfNeeded() {
      const btn = $("#fetchRatesBtn");
      const status = $("#fetchStatus");
      if (fxTimestamp && isWithin24h(fxTimestamp)) {
        btn.disabled = true;
        status.textContent = "Using cached rates (<24h).";
        status.classList.remove("bad"); status.classList.add("good");
      } else {
        btn.disabled = false;
        status.textContent = "You can fetch fresh rates.";
        status.classList.remove("bad"); status.classList.add("good");
      }
    }

    /***********************
     * FETCH RATES
     ***********************/
    async function fetchRates() {
      const btn = $("#fetchRatesBtn");
      const status = $("#fetchStatus");

      if (fxTimestamp && isWithin24h(fxTimestamp)) {
        status.textContent = "Already fetched in the last 24h.";
        status.classList.remove("bad"); status.classList.add("good");
        btn.disabled = true;
        return;
      }
      btn.disabled = true;
      status.textContent = "Fetching...";
      status.classList.remove("good", "bad");

      try {
        const res = await fetch("https://api.frankfurter.dev/v1/latest?symbols=GBP,RON,AUD");
        if (!res.ok) throw new Error("HTTP " + res.status + " " + res.statusText);
        const data = await res.json();
        const r = data.rates || {};
        fxRates = { EUR: 1, GBP: Number(r.GBP || 0), RON: Number(r.RON || 0), AUD: Number(r.AUD || 0) };
        fxTimestamp = Date.now();
        saveRatesToStorage();
        renderFxSnapshot();

        const missing = ["EUR", "GBP", "RON", "AUD"].filter(c => !fxRates[c] || fxRates[c] === 0);
        if (missing.length) {
          status.textContent = "Partial rates (missing " + missing.join(", ") + ").";
          status.classList.remove("good"); status.classList.add("bad");
        } else {
          status.textContent = "Rates updated.";
          status.classList.remove("bad"); status.classList.add("good");
        }
      } catch (err) {
        console.error(err);
        status.textContent = "ERROR. Use manual override.";
        status.classList.remove("good"); status.classList.add("bad");
        if (!fxTimestamp) btn.disabled = false;
      }
      lockFetchBtnIfNeeded();
    }

    /***********************
     * MANUAL RATES
     ***********************/
    function saveManualRates() {
      const gbp = parseFloat($("#manualGBP").value);
      const ron = parseFloat($("#manualRON").value);
      const aud = parseFloat($("#manualAUD").value);
      const status = $("#fetchStatus");
      if (!(gbp > 0 && ron > 0 && aud > 0)) {
        status.textContent = "All manual rates must be > 0.";
        status.classList.remove("good"); status.classList.add("bad");
        return;
      }
      fxRates = { EUR: 1, GBP: gbp, RON: ron, AUD: aud };
      fxTimestamp = Date.now();
      saveRatesToStorage();
      renderFxSnapshot();
      lockFetchBtnIfNeeded();
      status.textContent = "Manual rates saved.";
      status.classList.remove("bad"); status.classList.add("good");
    }

    /***********************
     * FX RENDER + HELPERS
     ***********************/
    function renderFxSnapshot() {
      const tsEl = $("#fxTimestamp");
      const tbl = $("#fxTable");
      if (!fxRates) { tsEl.textContent = "No rates loaded"; tbl.innerHTML = ""; return; }
      tsEl.textContent = new Date(fxTimestamp).toLocaleString() + " (EUR base)";
      const safe = v => (v && Number(v) > 0) ? Number(v).toFixed(4) : "—";
      tbl.innerHTML = `
        <div class="fx-row fx-row-inline"><div class="fx-cur">EUR</div><div class="fx-val">1.0000</div></div>
        <div class="fx-row fx-row-inline"><div class="fx-cur">GBP</div><div class="fx-val">${safe(fxRates.GBP)}</div></div>
        <div class="fx-row fx-row-inline"><div class="fx-cur">RON</div><div class="fx-val">${safe(fxRates.RON)}</div></div>
        <div class="fx-row fx-row-inline"><div class="fx-cur">AUD</div><div class="fx-val">${safe(fxRates.AUD)}</div></div>
      `;
    }
    function amountToEUR(amount, currency) {
      if (!fxRates || !fxRates[currency]) throw new Error("Unsupported currency " + currency);
      return amount / fxRates[currency]; // native -> EUR
    }
    function amountFromEUR(amountEUR, currency) {
      if (!fxRates || !fxRates[currency]) throw new Error("Unsupported currency " + currency);
      return amountEUR * fxRates[currency]; // EUR -> native
    }

    /***********************
     * TAX HELPERS
     ***********************/
    const stakeFee = c => (c === "RON" ? 0.05 : 0);
    const winTax = c => (c === "RON" ? 0.04 : 0);
    const isRomania = c => c === "RON";

    function effectiveStakeFromCash(stakeCash, currency) {
      return isRomania(currency) ? stakeCash * (1 - stakeFee(currency)) : stakeCash;
    }
    function computeSideFinancials(odds, stakeCash, currency) {
      const effStake = effectiveStakeFromCash(stakeCash, currency);
      const grossPayout = effStake * odds;
      const netPayout = isRomania(currency) ? grossPayout * (1 - winTax(currency)) : grossPayout;
      return { currency, stakeCash, effStake, grossPayout, netPayout };
    }

    /***********************
     * BALANCING COEFFICIENTS
     ***********************/
    // Pre-tax slip payout per 1 unit of *effective* stake is odds.
    // We need payout in EUR per 1 unit of *cash-in* for cross-currency balance.
    function preTaxCoeffEUR(odds, currency) {
      const rate = fxRates[currency];
      if (!rate || rate <= 0) throw new Error("FX missing for " + currency);
      // cash -> eff = cash*(1-sFee)
      // payout_native = eff * odds = cash*(1-sFee)*odds
      // payout_EUR = payout_native / rate
      return (1 - stakeFee(currency)) * odds / rate;
    }

    // After-tax net payout in EUR per 1 unit cash-in
    function afterTaxCoeffEUR(odds, currency) {
      const rate = fxRates[currency];
      if (!rate || rate <= 0) throw new Error("FX missing for " + currency);
      // cash -> eff = cash*(1-sFee)
      // gross = eff*odds
      // net = gross*(1-winTax)
      // EUR = net / rate
      return (1 - stakeFee(currency)) * odds * (1 - winTax(currency)) / rate;
    }

    function getBalancingMethod() {
      return $("#balAfter").checked ? "after" : "pre";
    }
    function updateBalBadge() {
      const badge = $("#balBadge");
      if (getBalancingMethod() === "after") {
        badge.textContent = "After-tax net payout (EUR)";
        badge.classList.add("badge-green");
        badge.classList.remove("badge-blue");
      } else {
        badge.textContent = "Pre-tax slip payout (EUR)";
        badge.classList.add("badge-blue");
        badge.classList.remove("badge-green");
      }
    }
    function updateRONHints() {
      const curA = $("#currencyA").value;
      const curB = $("#currencyB").value;
      setText("#hintA", isRomania(curA) ? "RON: −5% stake, −4% if wins" : "");
      setText("#hintB", isRomania(curB) ? "RON: −5% stake, −4% if wins" : "");

      // If any side is RON and user chose pre-tax, show hint recommending after-tax
      const anyRON = isRomania(curA) || isRomania(curB);
      if (anyRON && getBalancingMethod() === "pre") show($("#balHint"));
      else hide($("#balHint"));
    }

    /***********************
     * SIZING (3 MODES)
     ***********************/
    // Balance two sides so that payout_EUR matches per method.
    function balanceUsing(method, oddsA, oddsB, stakeKnown, knownSide, curA, curB) {
      const coeff = (method === "after") ? afterTaxCoeffEUR : preTaxCoeffEUR;
      const kA = coeff(oddsA, curA);
      const kB = coeff(oddsB, curB);

      if (knownSide === "A") {
        const stakeA_cash = stakeKnown;
        const stakeB_cash = (kA / kB) * stakeA_cash;
        return { stakeA_cash, stakeB_cash };
      } else {
        const stakeB_cash = stakeKnown;
        const stakeA_cash = (kB / kA) * stakeB_cash;
        return { stakeA_cash, stakeB_cash };
      }
    }

    function solveFromStakeA(oddsA, oddsB, stakeA_cash, curA, curB) {
      return balanceUsing(getBalancingMethod(), oddsA, oddsB, stakeA_cash, "A", curA, curB);
    }
    function solveFromStakeB(oddsA, oddsB, stakeB_cash, curA, curB) {
      return balanceUsing(getBalancingMethod(), oddsA, oddsB, stakeB_cash, "B", curA, curB);
    }
    function solveFromTargetEUR(oddsA, oddsB, targetPayoutEUR, curA, curB) {
      const method = getBalancingMethod();
      const coeff = (method === "after") ? afterTaxCoeffEUR : preTaxCoeffEUR;
      const kA = coeff(oddsA, curA);
      const kB = coeff(oddsB, curB);
      // target is payout in EUR (per method) on both sides
      const stakeA_cash = targetPayoutEUR / kA;
      const stakeB_cash = targetPayoutEUR / kB;
      return { stakeA_cash, stakeB_cash };
    }

    /***********************
     * SUMMARY / OUTCOMES
     ***********************/
    function summarizeOutcomes(oddsA, oddsB, stakeA_cash, stakeB_cash, curA, curB) {
      const sideA = computeSideFinancials(oddsA, stakeA_cash, curA);
      const sideB = computeSideFinancials(oddsB, stakeB_cash, curB);

      const totalCostEUR = amountToEUR(sideA.stakeCash, curA) + amountToEUR(sideB.stakeCash, curB);

      const collectA_EUR = amountToEUR(sideA.netPayout, curA);
      const profitIfA_EUR = collectA_EUR - totalCostEUR;
      const roiIfA = (profitIfA_EUR / totalCostEUR) * 100;

      const collectB_EUR = amountToEUR(sideB.netPayout, curB);
      const profitIfB_EUR = collectB_EUR - totalCostEUR;
      const roiIfB = (profitIfB_EUR / totalCostEUR) * 100;

      const guaranteedProfitEUR = Math.min(profitIfA_EUR, profitIfB_EUR);
      const guaranteedRoiPct = Math.min(roiIfA, roiIfB);

      return {
        sideA, sideB, totalCostEUR,
        collectA_EUR, collectB_EUR,
        profitIfA_EUR, profitIfB_EUR,
        roiIfA, roiIfB,
        guaranteedProfitEUR, guaranteedRoiPct
      };
    }

    /***********************
     * ARB CHECK
     ***********************/
    function arbAnalysis(oddsA, oddsB) {
      const invSum = (1 / oddsA) + (1 / oddsB);
      const hasArb = invSum < 1;
      const retFactor = 1 / invSum;
      const arbPct = (retFactor - 1) * 100;
      return { hasArb, arbPct };
    }

    /***********************
     * RENDER
     ***********************/
    function renderResults(oddsA, oddsB, curA, curB, stakeA_cash, stakeB_cash, summary, arbInfo) {
      // Your stakes
      setText("#sideAOddsOut", `@ ${oddsA.toFixed(2)}`);
      setText("#stakeACashOut", `${stakeA_cash.toFixed(2)} ${curA}`);
      setText("#stakeAEffOut", `${summary.sideA.effStake.toFixed(2)} ${curA}` + (isRomania(curA) ? " (after 5%)" : ""));

      setText("#sideBOddsOut", `@ ${oddsB.toFixed(2)}`);
      setText("#stakeBCashOut", `${stakeB_cash.toFixed(2)} ${curB}`);
      setText("#stakeBEffOut", `${summary.sideB.effStake.toFixed(2)} ${curB}` + (isRomania(curB) ? " (after 5%)" : ""));

      // Outcomes A / B
      setText("#collectAOut", `${summary.sideA.netPayout.toFixed(2)} ${curA} (after tax)`);
      setText("#totalCostAOut", `${summary.totalCostEUR.toFixed(2)} EUR`);
      setText("#profitAEurOut", `${summary.profitIfA_EUR.toFixed(2)} EUR`);
      setText("#roiAOut", `${summary.roiIfA.toFixed(2)} %`);

      setText("#collectBOut", `${summary.sideB.netPayout.toFixed(2)} ${curB} (after tax)`);
      setText("#totalCostBOut", `${summary.totalCostEUR.toFixed(2)} EUR`);
      setText("#profitBEurOut", `${summary.profitIfB_EUR.toFixed(2)} EUR`);
      setText("#roiBOut", `${summary.roiIfB.toFixed(2)} %`);

      // Guaranteed
      setText("#guaranteedProfitOut", `${summary.guaranteedProfitEUR.toFixed(2)} EUR`);
      setText("#guaranteedRoiOut", `${summary.guaranteedRoiPct.toFixed(2)} %`);

      if (arbInfo.hasArb) setText("#arbOut", `ARB ✅ +${arbInfo.arbPct.toFixed(2)}%`);
      else setText("#arbOut", `NO ARB ❌ ${arbInfo.arbPct.toFixed(2)}%`);

      // FX used line
      const fxLine =
        `Using FX: 1€ = ` +
        `GBP ${fxRates?.GBP?.toFixed?.(4) ?? "—"}, ` +
        `RON ${fxRates?.RON?.toFixed?.(4) ?? "—"}, ` +
        `AUD ${fxRates?.AUD?.toFixed?.(4) ?? "—"}.`;
      setText("#fxUsedLine", fxLine);

      show($("#calcResult"));
    }

    /***********************
     * UI HELPERS
     ***********************/
    function refreshModeUI() {
      const stakeAOption = document.querySelector('.mode-option:nth-of-type(1)');
      const stakeBOption = document.querySelector('.mode-option:nth-of-type(2)');
      const targetEUROption = document.querySelector('.mode-option:nth-of-type(3)');

      if ($("#modeStakeA").checked) {
        stakeAOption.classList.add("active");
        stakeBOption.classList.remove("active");
        targetEUROption.classList.remove("active");
      } else if ($("#modeStakeB").checked) {
        stakeBOption.classList.add("active");
        stakeAOption.classList.remove("active");
        targetEUROption.classList.remove("active");
      } else {
        targetEUROption.classList.add("active");
        stakeAOption.classList.remove("active");
        stakeBOption.classList.remove("active");
      }
    }

    /***********************
     * CALCULATE
     ***********************/
    function onCalculate(e) {
      e.preventDefault();

      const err = $("#calcError");
      hide(err);

      if (!fxRates) {
        err.textContent = "No FX snapshot loaded. Fetch or enter manual rates first.";
        show(err); hide($("#calcResult")); return;
      }

      const oddsA = parseFloat($("#oddsA").value);
      const oddsB = parseFloat($("#oddsB").value);
      if (!(oddsA > 1 && oddsB > 1)) {
        err.textContent = "Odds must be > 1.00";
        show(err); hide($("#calcResult")); return;
      }

      const curA = $("#currencyA").value;
      const curB = $("#currencyB").value;
      updateRONHints();

      const mode = $("#modeStakeA").checked ? "stakeA" : ($("#modeStakeB").checked ? "stakeB" : "targetEUR");

      let stakeA_cash, stakeB_cash;
      try {
        if (mode === "stakeA") {
          const v = parseFloat($("#stakeA").value);
          if (!(v > 0)) throw new Error("Stake A must be > 0 in 'I know Stake A' mode.");
          ({ stakeA_cash, stakeB_cash } = solveFromStakeA(oddsA, oddsB, v, curA, curB));
        } else if (mode === "stakeB") {
          const v = parseFloat($("#stakeB").value);
          if (!(v > 0)) throw new Error("Stake B must be > 0 in 'I know Stake B' mode.");
          ({ stakeA_cash, stakeB_cash } = solveFromStakeB(oddsA, oddsB, v, curA, curB));
        } else {
          const v = parseFloat($("#targetPayout").value);
          if (!(v > 0)) throw new Error("Target EUR must be > 0 in 'Target guaranteed payout in EUR' mode.");
          ({ stakeA_cash, stakeB_cash } = solveFromTargetEUR(oddsA, oddsB, v, curA, curB));
        }
      } catch (ex) {
        err.textContent = ex.message || String(ex);
        show(err); hide($("#calcResult")); return;
      }

      let summary;
      try {
        summary = summarizeOutcomes(oddsA, oddsB, stakeA_cash, stakeB_cash, curA, curB);
      } catch (ex) {
        err.textContent = ex.message || String(ex);
        show(err); hide($("#calcResult")); return;
      }

      const arbInfo = arbAnalysis(oddsA, oddsB);
      renderResults(oddsA, oddsB, curA, curB, stakeA_cash, stakeB_cash, summary, arbInfo);
    }

    /***********************
     * INIT
     ***********************/
    function init() {
      $("#fetchRatesBtn").addEventListener("click", fetchRates);
      $("#calcBtn").addEventListener("click", onCalculate);
      const manualBtn = $("#saveManualBtn");
      if (manualBtn) manualBtn.addEventListener("click", saveManualRates);

      // mode visuals
      $("#modeStakeA").addEventListener("change", refreshModeUI);
      $("#modeStakeB").addEventListener("change", refreshModeUI);
      $("#modeTargetEUR").addEventListener("change", refreshModeUI);
      refreshModeUI();

      // balancing UI
      $("#balAfter").addEventListener("change", () => { updateBalBadge(); updateRONHints(); });
      $("#balPre").addEventListener("change", () => { updateBalBadge(); updateRONHints(); });

      // currency hints + recommend after-tax if RON present
      $("#currencyA").addEventListener("change", () => {
        updateBalBadge();
        updateRONHints();
        // auto-default to after-tax when any side is RON
        if (isRomania($("#currencyA").value) || isRomania($("#currencyB").value)) {
          $("#balAfter").checked = true; updateBalBadge();
        }
      });
      $("#currencyB").addEventListener("change", () => {
        updateBalBadge();
        updateRONHints();
        if (isRomania($("#currencyA").value) || isRomania($("#currencyB").value)) {
          $("#balAfter").checked = true; updateBalBadge();
        }
      });

      loadRatesFromStorage();
      lockFetchBtnIfNeeded();
      renderFxSnapshot();
      updateBalBadge();
      updateRONHints();
    }
    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
